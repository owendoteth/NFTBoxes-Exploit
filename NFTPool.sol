pragma solidity ^0.8.0;

interface INFTBoxes {
	function buyManyBoxes(uint256 _id, uint128 _quantity) external payable;
    function setApprovalForAll(address operator, bool _approved) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function balanceOf(address owner) external view returns (uint256 balance);
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
}

//@author => owen.eth
//code needs to be cleaned up for redundancy

contract NFTPool {

    struct Request {
        uint256 amountETH;
        uint128 amountNFT;
    }

    address _owner;
    uint256 boxPrice;
    uint128 amountBoxesBought;
    mapping(address => bool) admin;
    mapping(address => bool) validUser;
    mapping(address => Request) requests;
    mapping(uint256 => uint256) NFTBalance;


    modifier onlyOwner {
        require(msg.sender == _owner, "You are not the owner!");
        _;
    }
    modifier onlyAdmin {
        require(admin[msg.sender] == true, "You are not an admin!");
        _;
    }

    modifier onlyUser {
        require(validUser[msg.sender] == true, "Invalid User!");
        _;
    }

    receive() external payable onlyUser {

        if(!admin[msg.sender]) {
            uint256 tax = msg.value / 10; //10% tax on deposit
            uint256 amount = msg.value - tax;
            require(div(amount, boxPrice) >= 1); //require the amount after tax is atleast the price of 1 box
            requests[msg.sender].amountETH = requests[msg.sender].amountETH + amount; //add deposit to user balance
            requests[_owner].amountETH = requests[_owner].amountETH + tax; //add taxed amount to owner balance
            requests[msg.sender].amountNFT = uint128(div(requests[msg.sender].amountETH, boxPrice)); //calculate the amount of boxes req for user
            requests[_owner].amountNFT = uint128(div(requests[_owner].amountETH, boxPrice)); //calcualte amount of boxes set aside for owner

        }
        else
        {
            requests[msg.sender].amountETH = requests[msg.sender].amountETH + msg.value; //add deposit to user balance
            requests[msg.sender].amountNFT = uint128(div(requests[msg.sender].amountETH, boxPrice)); //calculate the amount of boxes req for user

        }
    }

    INFTBoxes NFTBox;
    constructor(address _NFTBoxes, uint256 _boxPrice) {
        NFTBox = INFTBoxes(_NFTBoxes);
        _owner = msg.sender;
        validUser[msg.sender] = true;
        admin[msg.sender] = true;
        requests[msg.sender] = Request(0,0);
        boxPrice = _boxPrice;

    }

    function addUser(address _user) external onlyAdmin {
        validUser[_user] = true;
        requests[_user] = Request(0, 0);
    }

    //add admin in case author is unable to run script at time of drop
    function addAdmin(address _user) external onlyOwner {
        admin[_user] = true;
    }

    //buy all requested boxes in single TX (exploit) => this will be the function called from frontend script
    function buyBoxes(uint256 _id, uint128 _quantityPerTx) external payable onlyAdmin {
        uint128 amountReq =  uint128(div(address(this).balance, boxPrice));
        if(amountReq % 10 != 0) {
            requests[_owner].amountNFT =  requests[_owner].amountNFT + 1; //if amount of boxes req is not div by 10 (tax amount), give the owner one extra box to avoid box being locked in contract
        }
        while(amountReq % 2 != 0)  {
            amountReq = amountReq - 1;
        }
        while(amountBoxesBought < amountReq) {
            NFTBox.buyManyBoxes{value: boxPrice * _quantityPerTx}(_id, _quantityPerTx);
            amountBoxesBought = amountBoxesBought + _quantityPerTx;
        }
    }

    //withdraw NFTs to multiple accounts given an address list and quantity per account.
    function withdrawManyNFT(address[] memory _accounts, uint128 _quantityPerAccount) external payable onlyUser {
        require(requests[msg.sender].amountNFT >= 1); //require user has NFT to withdraw
        require(mul(_accounts.length, _quantityPerAccount) <= amountBoxesBought); //req is lower or equal to total amount bought
        require(mul(_accounts.length, _quantityPerAccount) <= requests[msg.sender].amountNFT); //require amount of accounts * amount per account <= req NFT amount per user

        getOwnedBoxes();
        uint128 c = 0;
        for(uint i = 0; i < _accounts.length; i++) {
            NFTBox.setApprovalForAll(_accounts[i], true);
            for(uint128 x = 0; x < _quantityPerAccount; x++) {
                NFTBox.safeTransferFrom(address(this), _accounts[i], NFTBalance[i]);
                requests[msg.sender].amountNFT = requests[msg.sender].amountNFT - 1; //remove NFT from req
                requests[msg.sender].amountETH = requests[msg.sender].amountETH - boxPrice; //remove equal ETH amount
                amountBoxesBought = amountBoxesBought - 1; //remove box from supply
                c = c + 1; //increase list index of owned box ids for next tx;
            }
        }
    }

    //withdraw NFTs from contract 1 at a time by ID to whomever the function caller is.
    function safeWithdrawNFT() external payable onlyUser{
        require(requests[msg.sender].amountNFT >= 1); //ensure user has withdrawable NFT
        require(requests[msg.sender].amountETH > 0); //ensure user has not withdrawn their ETH balance yet
        NFTBox.setApprovalForAll(msg.sender, true);

        getOwnedBoxes();
        NFTBox.safeTransferFrom(address(this), msg.sender, NFTBalance[0]); //transfer the NFT from contract to caller

        requests[msg.sender].amountNFT = requests[msg.sender].amountNFT - 1; //remove NFT from req
        requests[msg.sender].amountETH = requests[msg.sender].amountETH - boxPrice; //remove equal ETH amount
        amountBoxesBought -= 1; //remove box from supply

    }

    //withdraws users leftover eth balance given all NFTs are withdrawn
    function safeWithdrawETH() external payable onlyUser {
        uint256 userBalance = requests[msg.sender].amountETH; //get users balance
        uint128 userNFTBalance = requests[msg.sender].amountNFT; //get users NFT balance
        require(userBalance > 0); //user balance > 0
        payable(msg.sender).transfer(userBalance); //transfer ETH
        requests[msg.sender].amountETH = 0; //set user balance to zero
        requests[msg.sender].amountNFT =  0; //remove NFT amount from user request

    }

    //get mapping of NFTs owned by this contract
    function getOwnedBoxes() internal {
        uint256 nfts = NFTBox.balanceOf(address(this));
        for(uint i = 0; i < nfts; i++) {
            NFTBalance[i] = NFTBox.tokenOfOwnerByIndex(address(this), i);
        }
    }

    //get info about the users request (for use on frontend)
    function getUser(address _user) external view returns(uint256, uint128) {
        return (requests[_user].amountETH, requests[_user].amountNFT);
    }

    // SAFE MATH
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
}
